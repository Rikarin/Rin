import Core;

alias string = let(char)[] // string is just array of immutable chars

func add(a: int, b: int) -> int {
    return a + b
}

private func sub(a: int, b: int) throws -> int {
    return a - b
}


class BaseClass {
    final func dup(this R)() -> R {
        var ret = typeid(self).create()
        ret.__self()

        return ret
    }
}

class TestClass {
    private enum m_compilerMacroWuthoutAddress = "TestEnum"
    private ushort m_typedVar = 100
    private var m_number      = 42 // default long?
    private let m_constVar    = 50


    self(number: int) {
        m_number = number
    }

    ~self() {

    }

    func toString() -> string {
        return "TestClass"
    }

    class func makeInstance() -> TestClass {
        return TestClass()
    }
}


extend TestClass {
    private ubyte m_flag;

    ulong id() {
        get
        set

        set(TestClass value) {
            _value = value.toInt()
        }
    }

    func toInt() -> int {
        return 42
    }
}

enum TestEnum {
    First,
    Second,
    Third
}

func ifExample(aVar: TestEnum) {
    if (aVar == .First) {

    } else {

    }

    final switch (aVar) {
        case .First {

        }

        case .Second {

        }

        case .Third {

        }
    }
}


func varExample(arrayVar: int[], arrayVar2: int[42], arrayVar3: ref int[], delegateVar: (int, string) -> bool, tupleVar: (int, string, ushort, TestClass)) -> (string, string, typeof(arrayVar)) {

    var createArray = int[arrayVar?[30]]; // maybe monad. If arrayVar doesn;t have 30 idx, don;t create array

    delegateVar?() // call delegate if is not null

    var testClass = TestClass()
    var otherClass = testClass as OtherClass

    otherClass?.toInt()

    if (createArray !is null) {
        unsafe {
            memset(createArray.ptr, 0, createArray.length)
        }
    }

    int num
    mixin("num++")

    return ("test", "test2", [5, 6, 7, 8])
}


func takeMap(map: int[string]) -> (int, string) {
    var list = List!int
    list.add(1).add(2).add(3)

    return (map.first.value, map.first.key)
}





class List(T) if (is(T : TestClass)) {
    private T[] m_array

    func add(self R)(T value) -> R {
        m_array ~= value
        return self
    }
}





func maybeMonadVars(name: string, age: int?) {
    let a = age.value // Error if age is not set

    if (age) {
        let b = age.value // correct way, or maybe monad with ?.
    }
    
    let c = age?.value // Correct way too, but c will be uninitialized(set to default value) if age is false
}

func callMaybeMonadVars() {
    maybeMonadVars(name: "test", age: 42)
    maybeMonadVars(name: "withoutAge") // correct way, becasue age is maybe monad var, so will be setted to false
}


func mmVars2(name: string?, age: int?, number: ulong?, data: (int, int, string, double) -> ucent {
    return 42
}


func callmmVars2() {
    mmVars2(data: (5, 10, "test", 42.0)) // maybe monad vars should be ommited
}


func returnmmVar() -> string? {
    // return is not needed
}

func returnmmVar2() -> (stirng, int, int, double[string]) {
    // same
}


int? num
num = 42 // set value
int val = num? // val = (num.isSet ? num.value : val);
num? = null


override deprecated("don't use it") {
    func test() const throws -> const Object {

    }
}


class func test() {

}

class { // this seems ...
    func test() {

    }
}

{
class:
deprecated("test"):
...

}


func test() {
    let x = 42

    func local() {
        let y = x
    }

    global func glob() {
        let y = x // no context pointer to test() scope
    }
}



struct TimeInterval {
    long timestamp // hnsec = secs * 1000 (ms) * 100 (hnsecs)
}


func seconds(secs: int) -> TimeInterval {
    return TimeInterval(secs * 1000 * 100)
}
// OR maybe like this?
extend int {
    TimeInterval seconds() {
        get {
            return TimeInterval(self.value * 1000 * 100)
        }
    }
}

func sleep(for: TimeInterval) {
    // Do some stuff here
}

unittest {
    sleep(for: TimeInterval(5000000))
    sleep(TimeInterval(500)) // without function name
    sleep(5.seconds) // UFCS
    
    TimeInterval(5000).sleep // UFCS
    5.seconds.sleep // UFCS, () should be ommited
}



func overload(window: int) {

}

func overload(view: int) {

}

unittest {
    overload(window: 42) // OK
    overload(view: 42) // OK
    
    overload(42) // ERROR, which method will be called?
    42.overload() // ERROR same
}


